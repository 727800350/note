snippet handler "handler template"
// ${1:Template}Handler .
type $1Handler struct {
	ctx  context.Context
	req  *$2.$1Request
	rsp  *$2.$1Response
	code int32
	msg  string
}

// New$1Handler .
func New$1Handler(ctx context.Context, req *$2.$1Request) *$1Handler {
	return &$1Handler{
		ctx: ctx,
		req: req,
		rsp: &$2.$1Response{
			HttpCode: http.StatusOK,
			BaseResp: base.NewBaseResp(),
		},
		code: fault.RetCodeInternalErr,
	}
}

// Handle .
func (h *$1Handler) Handle() *$2.$1Response {
	if err := h.isValid(); err != nil {
		return h.returnAhead(errors.Trace(err))
	}

	if err := h.check(); err != nil {
		return h.returnAhead(errors.Trace(err))
	}

	return h.rsp
}

func (h *$1Handler) isValid() error {
	h.code = fault.RetCodeParamErr

	h.code = fault.RetCodeInternalErr
	return nil
}

func (h *$1Handler) check() error {
	return nil
}

func (h *$1Handler) returnAhead(err error) *$2.$1Response {
	if err == nil {
		return h.rsp
	}

	logs.CtxError(h.ctx, "$1 error %d %+v", h.code, err)
	h.rsp.BaseResp.StatusCode = h.code
	if h.msg == "" {
		h.msg = fault.GetErrorMessage(h.code)
	}
	h.rsp.BaseResp.StatusMessage = h.msg
	return h.rsp
}

func (h *$1Handler) emitError(reason string) {
	bmetrics.EmitCounter("$1.error.count", 1, metrics.Tag("reason", reason))
}
endsnippet

snippet ut "unit test template"
type ${1:Template}Suite struct {
	suite.Suite
	ctx context.Context
}

func (s *$1Suite) SetupSuite() {
}

func (s *$1Suite) TearDownSuite() {
}

func (s *$1Suite) SetupTest() {
	ctx := context.Background()
	ctx = kitutil.NewCtxWithLogID(ctx, logid.GenLogID())
	s.ctx = ctx
}

func (s *$1Suite) TearDownTest() {
	defer logs.Flush()
}

func (s *$1Suite) TestEx() {
	assert := s.Assert()
	t := s.T()
}

func Test$1(t *testing.T) {
	suite.Run(t, new($1Suite))
}
endsnippet

snippet handler_faas_cronjob "faas cronjob handler template"
// ${1:Template}Handler .
type $1Handler struct {
	ctx  context.Context
	rsp  *events.EventResponse
	code int32
}

// New$1Handler .
func New$1Handler(ctx context.Context, event *triggerEventData) *$1Handler {
	return &$1Handler{
		ctx: ctx,
		rsp: &events.EventResponse{
			StatusCode: http.StatusOK,
		},
		code: fault.RetCodeInternalErr,
	}
}

// Handle .
func (h *$1Handler) Handle() *events.EventResponse {
	return h.rsp
}

func (h *$1Handler) returnAhead(err error) *events.EventResponse {
	if err == nil {
		return h.rsp
	}

	logs.CtxError(h.ctx, "$1 error %v %+v", h.code, err)
	h.rsp.StatusCode = int(fault.GetHTTPCode(h.code))
	h.rsp.Headers["code"] = strconv.FormatInt(int64(h.code), 10)
	h.rsp.Body = []byte(err.Error())
	return h.rsp
}

func (h *$1Handler) emitError(reason string) {
	bmetrics.EmitCounter("$1.error.count", 1, metrics.Tag("reason", reason))
}
endsnippet

