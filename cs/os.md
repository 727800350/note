## 并行与并发
并发和并行是即相似又有区别的两个概念,并行是指两个或者多个事件在同一时刻发生,而并发是指两个或多个事件在同一时间间隔内发生.

在多道程序环境下,并发性是指在一段时间内宏观上有多个程序在同时运行,但在单处理机系统中,每一时刻却仅能有一道程序执行,故微观上这些程序只能是分时地交替执行.
倘若在计算机系统中有多个处理机,则这些可以并发执行的程序便可被分配到多个处理机上,实现并行执行,即利用每个处理机来处理一个可并发执行的程序,这样,多个程序便可以同时执行.

进程 Process

- 进程是指在系统中能独立运行并作为资源的分配的基本单位, 他是一组机器指令, 数据和堆栈等组成的, 是一个能独立运行的活动实体
- 多个进程之间可以并发执行和交换信息.
- 一个进程在运行时需要一定的资源, 如CPU, 存储空间及I/O设备等

线程

- 线程是进程的实体, 是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.
- 一个进程可以包含若干个线程, 多个线程也可以并发执行
- 将进程作为分配资源的基本单位, 而把线程作为独立运行和调度的基本单位.

线程同步的方式有哪些?

- 互斥量:采用互斥对象机制,只有拥有互斥对象的线程才有访问公共资源的权限.因为互斥对象只有一个,所以可以保证公共资源不会被多个线程同时访问.
- 信号量:它允许同一时刻多个线程访问同一资源,但是需要控制同一时刻访问此资源的最大线程数量.
- 事件(信号):通过通知操作的方式来保持多线程同步,还可以方便的实现多线程优先级的比较操作, `pthread_cond_signal, pthread_cond_wait`.

进程的通信方式有哪些?

主要分为:管道,系统IPC(包括消息队列,信号量,共享存储),SOCKET

- 管道是一种半双工的通信方式,数据只能单项流动,并且只能在具有亲缘关系的进程间流动,进程的亲缘关系通常是父子进程.
	管道主要分为:普通管道PIPE ,流管道(s_pipe),命名管道(name_pipe).
	命名管道也是半双工的通信方式,它允许无亲缘关系的进程间进行通信.
- 信号量是一个计数器,用来控制多个进程对资源的访问,它通常作为一种锁机制.
- 消息队列是消息的链表,存放在内核中并由消息队列标识符标识.
- 信号是一种比较复杂的通信方式,用于通知接收进程某个事件已经发生, 信号注册函数
- 共享内存就是映射一段能被其它进程访问的内存,这段共享内存由一个进程创建,但是多个进程可以访问.

什么是死锁？死锁产生的条件？

在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。

死锁产生的四个条件（有一个条件不成立，则不会产生死锁）

1. 互斥条件：一个资源一次只能被一个进程使用
1. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放
1. 不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺
1. 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系

分页和分段有什么区别？

- 段是信息的逻辑单位，它是根据用户的需要划分的, 例如程序段, 数据段, 因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。
- 段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定
- 段向用户提供二维地址空间；页向用户提供的是一维地址空间
- 段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。

# 操作系统的基本特性
1) 进程(线程)管理

大多数的微内核OS,对于进程管理功能的实现,都采用"机制与策略分离"的原理.例如,为实现进程(线程)调度功能,须在进程管理中设置一个或多个进程(线程)优先级队列,能将指定优先级进程(线程)从所在队列中取出,并将其投入执行.由于这一部分属于调度功能的机制部分,应将它放入微内核中.应如何确定每类用户(进程)的优先级,以及应如何修改它们的优先级等,都属于策略问题,可将它们放入微内核外的进程(线程)管理服务器中.

2) 低级存储器管理

通常在微内核中,只配置最基本的低级存储器管理机制.如用于实现将用户空间的逻辑地址变换为内存空间的物理地址的页表机制和地址变换机制,这一部分是依赖于机器的,因此放入微内核.而实现虚拟存储器管理的策略,则包含应采取何种页面置换算法,采用何种内存分配与回收策略等,应将这部分放在微内核外的存储器管理服务器中去实现.

3) 中断和陷入处理

大多数微内核操作系统都是将与硬件紧密相关的一小部分放入微内核中处理.此时微内核的主要功能,是捕获所发生的中断和陷入事件,并进行相应的前期处理.如进行中断现场保护,识别中断和陷入的类型,然后将有关事件的信息转换成消息后,把它发送给相关的服务器.由服务器根据中断或陷入的类型,调用相应的处理程序来进行后期处理.

在微内核OS中是将进程管理,存储器管理以及I/O管理这些功能一分为二,属于机制的很小一部分放入微内核中,另外绝大部分放在微内核外的各种服务器中来实现.事实上,其中大多数服务器都比微内核大.这进一步说明了为什么能在采用客户/服务器模式后,还能把微内核做得很小的原因.

存在的问题

应当指出,在微内核OS中,由于采用了非常小的内核,以及客户/服务器模式和消息传递机制,这些虽给微内核OS带来了许多优点,但由此也使微内核OS存在着潜在的缺点.其中最主要的是,较之早期OS,微内核OS的运行效率有所降低.

效率降低的最主要的原因是,在完成一次客户对OS提出的服务请求时,需要利用消息实现多次交互和进行用户/内核模式及上下文的多次切换.

然而,在早期的OS中,用户进程在请求取得OS服务时,一般只需进行两次上下文的切换:一次是在执行系统调用后,由用户态转向系统态时,另一次是在系统完成用户请求的服务后,由系统态返回用户态时.

在微内核OS中,由于客户和服务器及服务器和服务器之间的通信,都需通过微内核,致使同样的服务请求至少需要进行四次上下文切换.第一次是发生在客户发送请求消息给内核,以请求取得某服务器特定的服务时,第二次是发生在由内核把客户的请求消息发往服务器时,第三次是当服务器完成客户请求后,把响应消息发送到内核时,第四次是在内核将响应消息发送给客户时.

实际情况是往往还会引起更多的上下文切换.例如,当某个服务器自身尚无能力完成客户请求,而需要其它服务器的帮助时,其中的文件服务器还需要磁盘服务器的帮助,这时就需要进行八次上下文的切换.

# 进程管理与死锁
## 进程和线程的资源
一个标准的线程由线程ID,当前指令指针(PC),寄存器集合和堆栈组成.

另外,线程是进程中的一个实体,是被系统独立调度和分派的基本单位,线程自己不拥有系统资源,只拥有一点在运行中必不可少的资源,但它可与同属一个进程的其它线程共享进程所拥有的全部资源.

进程的资源虚拟地址空间,全局变量, 已代开文件, 定时器, 信号量等操作系统资源

### 用户级线程的实现
运行时系统(runtime system)

所谓运行时系统, 实质上是用于管理和控制线程的函数(过程)的集合, 其中包括创建和撤销线程的函数, 线程同步和通信的函数以及实现线程调度的函数等.

正因为这些函数, 才能使用户级线程与内核无关.

运行时系统中的所有函数都驻留在用户空间, 并作为用户级线程与内核之间的接口.

系统资源都是由内核管理的.

在传统的OS中, 进程是利用OS提供的系统调用请求系统资源的, 系统调用是通过软中断(trap)机制进入OS内核, 有内核完成相应资源的分配.

用户级线程是不能利用系统调用的. 当线程需要系统资源时, 是将该要求传送给运行时系统, 然后由后者通过相应的系统调用来获得系统资源的.

### 中断
软中断是利用硬件中断的概念,用软件方式进行模拟,实现宏观上的异步执行效果.很多情况下,软中断和"信号"有些类似,同时,软中断又是和硬中断相对应的,"硬中断是外部设备对CPU的中断","软中断通常是硬中断服务程序对内核的中断","信号则是由内核(或其他进程)对某个进程的中断"(<Linux内核源代码情景分析>第三章).

软中断是实现系统API函数调用的手段

函数调用时将返回地址和CPU状态寄存器内容压栈,函数执行完毕后出栈返回断点继续执行.

软中断调用时将返回地址和CPU状态寄存器内容压栈,修改特权级,根据中断号查找中断向量表,找到ISR中断服务例程地址,跳转执行.

综上,函数调用和软中断调用的区别是,软中断多了修改特权级和查找中断向量表的功能,其他部分完全一样.

一般,系统程序由软件公司实现且不开源,你无法知道系统API函数的偏移地址,而且你写的应用程序和软件公司提供的系统程序是完全分开的,编译器无法将二者链接在一起,同时,系统程序需要核心态特权才能运行,此时用函数调用的办法是无法调用系统API函数的.解决这个问题的方法是使用软中断,当应用程序需要调用API时,就先设置功能号(如AX=0H),然后触发软中断(如INT 80H).系统程序设置好中断向量表.这样,应用程序就可以间接找到系统API了.

内核控制线程

A light-weight process (LWP) is a means of achieving multitasking. In the traditional meaning of the term, as used in Unix System V andSolaris, a LWP runs in user space on top of a single kernel thread and shares its address space and system resources with other LWPs within the same process. Multiple user level threads, managed by a thread library, can be placed on top of one or many LWPs - allowing multitasking to be done at the user level, which can have some performance benefits.

用户级线程连接到LWP上, 便具有了内核支持线程的所有属性

# 处理机调度
优先数算法

轮转法

响应时间: 是从用户通过键盘提交一个请求开始, 直到系统首次产生响应为止的时间. 或者说, 直到屏幕上显示出结果为止的一段时间间隔.

它包括三部分时间: 从键盘输入的请求信息传送到处理机的时间, 处理机队请求信息进行处理的时间, 以及将形成的响应信息回送到终端显示器的时间.

银行家算法

思索的检测与解除

