# IO调度
IO调度发生在Linux内核的IO调度层.这个层次是针对Linux的整体IO层次体系来说的.从read()或者write()系统调用的角度来说,Linux整体IO体系可以分为七层,它们分别是:

1. VFS层:虚拟文件系统层.由于内核要跟多种文件系统打交道,而每一种文件系统所实现的数据结构和相关方法都可能不尽相同,所以,内核抽象了这一层,专门用来适配各种文件系统,并对外提供统一操作接口.
1. 文件系统层:不同的文件系统实现自己的操作过程,提供自己特有的特征,具体不多说了,大家愿意的话自己去看代码即可.
1. 页缓存层:负责对page的缓存.
1. 通用块层:由于绝大多数情况的io操作是跟块设备打交道,所以Linux在此提供了一个类似vfs层的块设备操作抽象层.下层对接各种不同属性的块设备,对上提供统一的Block IO请求标准.
1. IO调度层:因为绝大多数的块设备都是类似磁盘这样的设备,所以有必要根据这类设备的特点以及应用的不同特点来设置一些不同的调度算法和队列.
  以便在不同的应用环境下有针对性的提高磁盘的读写效率,这里就是大名鼎鼎的Linux电梯所起作用的地方.针对机械硬盘的各种调度方法就是在这实现的.
1. 块设备驱动层:驱动层对外提供相对比较高级的设备操作接口,往往是C语言的,而下层对接设备本身的操作方法和规范.
1. 块设备层:这层就是具体的物理设备了,定义了各种真对设备操作方法和规范.

我们今天要研究的内容主要在IO调度这一层.它要解决的核心问题是,如何提高块设备IO的整体性能?
这一层也主要是针对机械硬盘结构而设计的.众所周知,机械硬盘的存储介质是磁盘,磁头在盘片上移动进行磁道寻址,行为类似播放一张唱片.
这种结构的特点是,顺序访问时吞吐量较高,但是如果一旦对盘片有随机访问,那么大量的时间都会浪费在磁头的移动上,这时候就会导致每次IO的响应时间变长,极大的降低IO的响应速度.
磁头在盘片上寻道的操作,类似电梯调度,如果在寻道的过程中,能把顺序路过的相关磁道的数据请求都"顺便"处理掉,那么就可以在比较小影响响应速度的前提下,提高整体IO的吞吐量.
这就是我们问什么要设计IO调度算法的原因.

调度器工作的原理: 合并和排序.

查看和修改IO调度算法的方法是:
```bash
$ cat /sys/block/sda/queue/scheduler
noop deadline [cfq]
$ echo cfq > /sys/block/sda/queue/scheduler
```

## CFQ完全公平队列
目前内核中默认的调度算法应该是cfq,叫做完全公平队列调度.这个调度算法人如其名,它试图给所有进程提供一个完全公平的IO操作环境.
它为每个进程创建一个同步IO调度队列,并默认以时间片和请求数限定的方式分配IO资源,以此保证每个进程的IO资源占用是公平的,cfq还实现了针对进程级别的优先级调度.

cfq是通用服务器比较好的IO调度算法选择,对桌面用户也是比较好的选择.
但是对于很多IO压力较大的场景就并不是很适应,尤其是IO压力集中在某些进程上的场景.因为这种场景我们需要更多的满足某个或者某几个进程的IO响应速度,而不是让所有的进程公平的使用IO,比如数据库应用.

## deadline调度(最终期限调度)
deadline调度(最终期限调度)就是更适合上述场景的解决方案.
deadline实现了四个队列,其中两个分别处理正常read和write,按扇区号排序,进行正常io的合并处理以提高吞吐量.
因为IO请求可能会集中在某些磁盘位置,这样会导致新来的请求一直被合并,可能会有其他磁盘位置的io请求被饿死.
因此实现了另外两个处理超时read和write的队列,按请求创建时间排序,如果有超时的请求出现,就放进这两个队列,调度算法保证超时(达到最终期限时间)的队列中的请求会优先被处理,防止请求被饿死.

## NOOP调度器
noop调度器是最简单的调度器.它本质上就是一个链表实现的fifo队列,并对请求进行简单的合并处理.调度器本身并没有提供任何可疑配置的参数.

各种调度器的应用场景选择

根据以上几种io调度算法的分析,我们应该能对各种调度算法的使用场景有一些大致的思路了.
从原理上看,cfq是一种比较通用的调度算法,它是一种以进程为出发点考虑的调度算法,保证大家尽量公平.
deadline是一种以提高机械硬盘吞吐量为思考出发点的调度算法,尽量保证在有io请求达到最终期限的时候进行调度,非常适合业务比较单一并且IO压力比较重的业务,比如数据库.
而noop呢?其实如果我们把我们的思考对象拓展到固态硬盘,那么你就会发现,无论cfq还是deadline,都是针对机械硬盘的结构进行的队列算法调整,而这种调整对于固态硬盘来说,完全没有意义.
对于固态硬盘来说,IO调度算法越复杂,额外要处理的逻辑就越多,效率就越低.所以,固态硬盘这种场景下使用noop是最好的,deadline次之,而cfq由于复杂度的原因,无疑效率最低.

# 磁盘阵列 RAID
独立硬盘冗余阵列(RAID, Redundant Array of Independent Disks).
根据选择的版本不同,RAID比单颗硬盘有以下一个或多个方面的好处:增强数据集成度,增强容错功能,增加处理量或容量.另外,磁盘阵列对于电脑来说,看起来就像一个单独的硬盘或逻辑存储单元.

目前对RAID级别的定义可以获得业界广泛认同的有4种,RAID 0,RAID 1,RAID 0＋1和RAID 5, etc.

- RAID 0: 无数据冗余的存储空间条带化,具有成本低,读写性能极高,存储空间利用率高等特点, 但由于没有数据冗余,其安全性大大降低.
- RAID 1: 完全镜像, 两份数据同时写, 安全性高, 但空间利用率低
- RAID 4: 专门的一个磁盘(校验盘)在保存其他数据盘块交叉奇偶校验的结果, 每一次写操作都需要读所有的数据盘和校验盘, 因为需要计算校验位, 同时需要写校验盘. 校验盘成为写的瓶颈, 写性能很差.
- RAID 5: 类似raid4, 但校验信息可以分布在所有盘上, 使得写操作不存在单一的瓶颈. 写性能较差.

