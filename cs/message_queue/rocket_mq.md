# 消息类型概述
普通消息是指消息队列RocketMQ版中无特性的消息,区别于有特性的定时和延时消息,顺序消息和事务消息.

消息队列RocketMQ版提供的四种消息类型所对应的Topic不能混用,例如,创建的普通消息的Topic只能用于收发普通消息,不能用于收发其
他类型的消息,同理,事务消息的Topic也只能收发事务消息,不能用于收发其他类型的消息,以此类推.

顺序消息,定时消息,事务消息是不同的消息类型,三者是互斥关系,不能叠加在一起使用.

## 定时和延时消息
- 定时消息: Producer将消息发送到消息队列RocketMQ版服务端,但并不期望立马投递这条消息,而是推迟到在当前时间点之后的某一个时
  间投递到Consumer进行消费,该消息即定时消息.
- 延时消息:Producer将消息发送到消息队列RocketMQ版服务端,但并不期望立马投递这条消息,而是延迟一定时间后才投递到Consumer进
  行消费,该消息即延时消息.

定时消息与延时消息在代码配置上存在一些差异,但是最终达到的效果相同:消息在发送到消息队列RocketMQ版服务端后并不会立马投递,
而是根据消息中的属性延迟固定时间后才投递给消费者.

定时消息和延时消息适用于以下一些场景:

- 消息生产和消费有时间窗口要求,例如在电商交易中超时未支付关闭订单的场景,在订单创建时会发送一条延时消息.这条消息将会在30
  分钟以后投递给消费者,消费者收到此消息后需要判断对应的订单是否已完成支付.如支付未完成,则关闭订单.如已完成支付则忽略.
- 通过消息触发一些定时任务,例如在某一固定时间点向用户发送提醒消息.

## 顺序消息
顺序消息(FIFO消息)是消息队列RocketMQ版提供的一种严格按照顺序来发布和消费的消息.顺序发布和顺序消费是指对于指定的一个
Topic,生产者按照一定的先后顺序发布消息,消费者按照既定的先后顺序订阅消息,即先发布的消息一定会先被客户端接收到.

produce在发送消息的时候,把消息发到同一个队列(queue)中,消费者注册消息监听器为MessageListenerOrderly,这样就可以保证消费端
只有一个线程去消费消息.
注意:是把把消息发到同一个队列(queue),不是同一个topic,默认情况下一个topic包括4个queue.

顺序消息分为全局顺序消息和分区顺序消息.

**全局顺序消息**

对于指定的一个Topic,所有消息按照严格的先入先出(FIFO)的顺序来发布和消费.

适用场景: 适用于性能要求不高,所有的消息严格按照FIFO原则来发布和消费的场景.

示例: 在证券处理中,以人民币兑换美元为Topic,在价格相同的情况下,先出价者优先处理,则可以按照FIFO的方式发布和消费全局顺序消
息.

**分区顺序消息**

对于指定的一个Topic,所有消息根据Sharding Key进行区块分区.同一个分区内的消息按照严格的FIFO顺序进行发布和消费.Sharding Key
是顺序消息中用来区分不同分区的关键字段,和普通消息的Key是完全不同的概念.

适用场景: 适用于性能要求高,以Sharding Key作为分区字段,在同一个区块中严格地按照FIFO原则进行消息发布和消费的场景.

示例: 用户注册需要发送发验证码,以用户ID作为Sharding Key,那么同一个用户发送的消息都会按照发布的先后顺序来消费.
电商的订单创建,以订单ID作为Sharding Key,那么同一个订单相关的创建订单消息,订单支付消息,订单退款消息,订单物流消息都会按照
发布的先后顺序来消费.

## [事务消息](https://help.aliyun.com/document_detail/43348.html)
- 事务消息: RocketMQ 提供类似XA或Open XA的分布式事务功能,通过消息队列RocketMQ版事务消息能达到分布式事务的最终一致.
- 半事务消息: 暂不能投递的消息,发送方已经成功地将消息发送到了RocketMQ 服务端,但是服务端未收到生产者对该消息的二次确认,此
  时该消息被标记成"暂不能投递"状态,处于该种状态下的消息即半事务消息.
- 消息回查: 由于网络闪断,生产者应用重启等原因,导致某条事务消息的二次确认丢失,RocketMQ 服务端通过扫描发现某条消息长期处于
  "半事务消息"时,需要主动向消息生产者询问该消息的最终状态(Commit或是Rollback),该询问过程即消息回查.

典型场景

在淘宝购物车下单时,涉及到购物车系统和交易系统,这两个系统之间的数据最终一致性可以通过分布式事务消息的异步处理实现.
在这种场景下,交易系统是最为核心的系统,需要最大限度地保证下单成功.而购物车系统只需要订阅消息队列RocketMQ版的交易订单消息,
做相应的业务处理,即可保证最终的数据一致性.

事务消息发送步骤如下:

1. 发送方将半事务消息发送至消息队列RocketMQ版服务端.
1. 消息队列RocketMQ版服务端将消息持久化成功之后,向发送方返回Ack确认消息已经发送成功,此时消息为半事务消息.
1. 发送方开始执行本地事务逻辑.
1. 发送方根据本地事务执行结果向服务端提交二次确认(Commit或是Rollback),服务端收到Commit状态则将半事务消息标记为可投递,订
  阅方最终将收到该消息,服务端收到Rollback状态则删除半事务消息,订阅方将不会接受该消息.

事务消息回查步骤如下:

1. 在断网或者是应用重启的特殊情况下,上述步骤4提交的二次确认最终未到达服务端,经过固定时间后服务端将对该消息发起消息回查.
1. 发送方收到消息回查后,需要检查对应消息的本地事务执行的最终结果.
1. 发送方根据检查得到的本地事务的最终状态再次提交二次确认,服务端仍按照步骤4对半事务消息进行操作.

