Paxos协议由Leslie Lamport最早在1990年提出,由于Paxos在云计算领域的广泛应用Leslie Lamport因此获得了2013年度图灵奖.

Paxos协议提出只要系统中2f+1个节点中的f+1个节点可用,那么系统整体就可用并且能保证数据的强一致性.
它对于可用性的提升是极大的,仍然假设单节点的可用性是P,那么2f+1个节点中任意组合的f+1以上个节点正常的可用性
``$$P(total) = \sum_{i = f + 1}^{2f + 1} C(i, 2f + 1) * P^i * (1 - P)^(2f + 1 - i)$$
又假设P=0.99,f=2,P(total)=0.9999901494,可用性将从单节点的2个9提升到了5个9,这意味着系统每年的宕机时间从87.6小时降到0.086小时,这已经可以满足地球上99.99999999%的应用需求.

Leslie写的两篇论文:<The Part-Time Parliament>和<Paxos Made Simple>比较完整的阐述了Paxos的工作流程和证明过程.
Paxos协议把每个数据写请求比喻成一次提案(proposal),每个提案都有一个独立的编号,提案会转发到提交者(Proposer)来提交,提案必须经过2f+1个节点中的f+1个节点接受才会生效,
2f+1个节点叫做这次提案的投票委员会(Quorum),投票委员会中的节点叫做Acceptor,Paxos协议流程还需要满足两个约束条件: 

1. Acceptor必须接受它收到的第一个提案,
1. 如果一个提案的v值被大多数Acceptor接受过,那后续的所有被接受的提案中也必须包含v值(v值可以理解为提案的内容,提案由一个或多个v和提案编号组成).

Paxos协议流程划分为两个阶段,第一阶段是Proposer学习提案最新状态的准备阶段,第二阶段是根据学习到的状态组成正确提案提交的阶段,完整的协议过程如下:

1. 阶段 1.
  Proposer选择一个提案编号n ,然后向半数以上的Acceptors发送编号为 n 的prepare请求.
  如果一个Acceptor收到一个编号为n 的prepare请求,且 n 大于它已经响应的所有prepare请求的编号,那么它就会保证不会再通过(accept)任何编号小于 n 的提案,同时将它已经通过的最大编号的提案(如果存在的话)作为响应.
1. 阶段 2.
  如果Proposer收到来自半数以上的Acceptor对于它的prepare请求(编号为n)的响应,那么它就会发送一个针对编号为n, value值为v 的提案的accept请求给Acceptors,
  在这里v 是收到的响应中编号最大的提案的值,如果响应中不包含提案,那么它就是任意值.
  如果Acceptor收到一个针对编号n 的提案的accept请求,只要它还未对编号大于n 的prepare请求作出响应,它就可以通过这个提案.

Paxos协议的核心可以简单描述为:Proposer先从大多数Acceptor那里学习提案的最新内容,然后根据学习到的编号最大的提案内容组成新的提案提交,如果提案获得大多数Acceptor的投票通过就意味着提案被通过.
由于学习提案和通过提案的Acceptor集合都超过了半数,所以一定能学到最新通过的提案值,两次提案通过的Acceptor集合中也一定存在一个公共的Acceptor,在满足约束条件2时这个公共的Acceptor时保证了数据的一致性,
于是Paxos协议又被称为多数派协议.

Paxos协议的真正伟大之处在于它的简洁性,Paxos协议流程中任何消息都是可以丢失的,一致性保证并不依赖某个特殊消息传递的成功,这极大的简化了分布式系统的设计,极其匹配分布式环境下网络可能分区的特点,
相比较在Paxos协议之前的"两阶段提交(2PC)"也能保证数据强一致性,但复杂度相当高且依赖单个协调者的可用性.

那既然Paxos如此强大,那为什么还会出现ZAB协议?

Paxos协议虽然是完备的,但要把它应用到实际的分布式系统中还有些问题要解决:

1. 在多个Proposer的场景下,Paxos不保证先提交的提案先被接受,实际应用中要保证多提案被接受的先后顺序怎么办?
1. Paxos允许多个Proposer提交提案,那有可能出现活锁问题,出现场景是这样的:提案n在第二阶段还没有完成时,新的提案n+1的第一阶段prepare请求到达Acceptor,
  按协议规定Acceptor将响应新提案的prepare请求并保证不会接受小于n+1的任何请求,这可能导致提案n将不会被通过,同样在n+1提案未完成第二阶段时,假如提案n的提交者又提交了n+2提案,这可能导致n+1提案也无法通过.
1. Paxos协议规定提案的值v只要被大多数Acceptor接受过,后续的所有提案不能修改值v,那现实情况下我还要修改v值怎么办?

ZooKeeper的核心算法ZAB通过一个简单的约束解决了前2个问题:所有提案都转发到唯一的Leader(通过Leader选举算法从Acceptor中选出来的)来提交,由Leader来保证多个提案之间的先后顺序,
同时也避免了多Proposer引发的活锁问题.

[分布式系统可用性与一致性](https://blog.csdn.net/congge_1993/article/details/73613689)

