# const
const in C does not mean something is constant. It just means a variable is read-only.

1. 为了防止传递的函数参数不被修改,在调用函数的形参中用const关键字.
2. `const int *p`: p是指向int常量的指针, `*p`是不变的, 但是可以将p指向其他变量
3. `int * const p`: p是指针常量, 也就是p不能变, 但是可以改变 `*p`
4. `const int * const p`: 同时满足前面两种情况
5. const并不会阻止参数的修改, 防君子不防小人, 可以强制的把 `const char *` 转换为 `char *`类型, 然后就可以修改了

在 C++(但不是在 C 语言)中, const 限定符对默认存储类型稍有影响.
在默认情况下, 全局变量的链接性为外部的, 但 const 全局变量的链接性为内部的.也就是说,在 C++ 看来, 全局 const 定义就像使用了 static 说明符一样.
因此,可以将 const 常量定义在头文件中供工程中的多个其它文件包含引用, 并且编译时不会产生变量重复定义的错误. 当然,也可以用 #define 宏定义.

ref: [头文件中定义const全局变量应注意的问题](http://blog.csdn.net/ace_fei/article/details/8587403)

## 一个函数名后面加const表示什么意思
在函数名后面表示是常成员函数, 该函数不能修改对象内的任何成员, 只能发生读操作, 不能发生写操作.
我们都知道在调用成员函数的时候编译器会将对象自身的地址作为隐藏参数传递给函数, 在const成员函数中,既不能改变this所指向的对象,也不能改变this所保存的地址,this的类型是一个指向const类型对象的const指针.

一个函数名字后有const, 这个函数必定是成员函数,也就是说普通函数后面不能有const修饰

# static
ref:

- [C语言中的static 详细分析](http://blog.csdn.net/keyeagle/article/details/6708077/)
- [static在C和C++中的用法和区别](http://blog.csdn.net/skyereeee/article/details/8000512)

c语言代码是以文件为单位来组织的,在一个源程序的所有源文件中,一个外部变量(注意不是局部变量)或者函数只能在一个源程序中定义一次,如果有重复定义的话编译器就会报错.
伴随着不同源文件变量和函数之间的相互引用以及相互独立的关系,产生了extern和static关键字.

一个进程在内存中的布局

```
----------
栈区
----------
堆栈增长区
----------
堆区
----------
其他段
----------
.bbs 段
----------
.data 段
----------
.text 段
----------
```
其中

- .text段保存进程所执行的程序二进制文件,
- .data段保存进程所有的已初始化的全局变量
- .bss段保存进程未初始化的全局变量(其他段中还有很多乱七八糟的段,暂且不表).

在进程的整个生命周期中,.data段和.bss段内的数据时跟整个进程同生共死的,也就是在进程结束之后这些数据才会寿终就寝.

### static全局变量
当一个进程的全局变量被声明为static之后,就是静态全局变量.
静态全局变量和其他的全局变量的存储地点并没有区别,都是在.data段(已初始化)或者.bss段(未初始化)内,但是它只在定义它的源文件内有效,其他源文件无法访问它.

### static局部变量
普通的局部变量在栈空间上分配,这个局部变量所在的函数被多次调用时,每次调用这个局部变量在栈上的位置都不一定相同.
局部变量也可以在堆上动态分配,但是记得使用完这个堆空间后要释放之.

static局部变量中文名叫静态局部变量.它与普通的局部变量比起来有如下几个区别:

1. 位置:静态局部变量被编译器放在全局存储区.data(注意:不在.bss段内,原因见3)),所以它虽然是局部的,但是在程序的整个生命周期中存在.
2. 访问权限:静态局部变量只能被其作用域内的变量或函数访问.也就是说虽然它会在程序的整个生命周期中存在,由于它是static的,它不能被其他的函数和源文件访问.
3. 值:静态局部变量如果没有被用户初始化,则会被编译器自动赋值为0,以后每次调用静态局部变量的时候都用上次调用后的值.
	这个比较好理解,每次函数调用静态局部变量的时候都修改它然后离开,下次读的时候从全局存储区读出的静态局部变量就是上次修改后的值.

需要注意的是由于static局部变量的这种特性,使得含静态局部变量的函数变得不可重入,即每次调用可能会产生不同的结果.这在多线程编程时可能会成为一种隐患.需要多加注意.

### static函数
相信大家还记得C++面向对象编程中的private函数,私有函数只有该类的成员变量或成员函数可以访问.
在C语言中,也有"private函数",它就是接下来要说的static函数,完成面向对象编程中private函数的功能.

当你的程序中有很多个源文件的时候,你肯定会让某个源文件只提供一些外界需要的接口,
其他的函数可能是为了实现这些接口而编写,这些其他的函数你可能并不希望被外界(非本源文件)所看到,这时候就可以用static修饰这些"其他的函数".

所以static函数的作用域是本源文件,把它想象为面向对象中的private函数就可以了.

### 静态数据成员／成员函数(C++特有)
C++ 重用了这个关键字,并赋予它与前面不同的第三种含义:表示属于一个类而不是属于此类的任何特定对象的变量和函数. 这是与普通成员函数的最大区别, 也是其应用所在.  
比如在对某一个类的对象进行计数时, 计数生成多少个类的实例, 就可以用到静态数据成员.  
在这里面, static既不是限定作用域的, 也不是扩展生存期的作用, 而是指示变量/函数在此类中的唯一性. 这也是"属于一个类而不是属于此类的任何特定对象的变量和函数"的含义. 
因为它是对整个类来说是唯一的,因此不可能属于某一个实例对象的.  
(针对静态数据成员而言, 成员函数不管是否是static, 在内存中只有一个副本, 普通成员函数调用时, 需要传入this指针, static成员函数调用时, 没有this指针)

# mutable
ref: [C++ 中mutable 关键字存在的必要性是什么?](https://www.zhihu.com/question/64969053/answer/226383958)

## 类中的 mutable
mutable 从字面意思上来说,是「可变的」之意.

若是要「顾名思义」,那么这个关键词的含义就有些意思了.显然,「可变的」只能用来形容变量,而不可能是「函数」或者「类」本身.
然而,既然是「变量」,那么它本来就是可变的,也没有必要使用 mutable 来修饰.那么,mutable 就只能用来形容某种不变的东西了.

C++ 中,不可变的变量,称之为常量,使用 const 来修饰.然而,若是 const mutable 联用,未免让人摸不着头脑-到底是可变还是不可变呢?

事实上,mutable 是用来修饰一个 const 示例的部分可变的数据成员的.如果要说得更清晰一点,就是说 mutable 的出现,将 C++ 中的 const 的概念分成了两种.

- 二进制层面的 const,也就是「绝对的」常量,在任何情况下都不可修改(除非用 `const_cast`).
- 引入 mutable 之后,C++ 可以有逻辑层面的 const,也就是对一个常量实例来说,从外部观察,它是常量而不可修改,但是内部可以有非常量的状态.
	当然,所谓的「逻辑 const」,只是为了方便理解,而创造出来的名词.
	显而易见,mutable 只能用来修饰类的数据成员,而被 mutable 修饰的数据成员,可以在 const 成员函数中修改.

这里举一个例子,展现这类情形.

```C++
class HashTable {
public:
	//...
	std::string lookup(const std::string& key) const {
		if (key == _last_key) {
			return _last_value;
		}

		std::string value{this->lookupInternal(key)};

		_last_key   = key;
		_last_value = value;

		return value;
	}

private:
	mutable std::string _last_key;
	mutable std::string _last_value;
};
```
这里,我们呈现了一个哈希表的部分实现.显然,对哈希表的查询操作,在逻辑上不应该修改哈希表本身.因此,HashTable::lookup 是一个 const 成员函数.
在 HashTable::lookup 中,我们使用了 `_last_key` 和 `_last_value` 实现了一个简单的「缓存」逻辑.
当传入的 key 与前次查询的 `_last_key` 一致时,直接返回 `_last_value`,否则,则返回实际查询得到的 value 并更新 `_last_key` 和 `_last_value`.

在这里,`_last_key` 和 `_last_value` 是 HashTable 的数据成员.按照一般的理解,const 成员函数是不允许修改数据成员的.
但是,另一方面,`_last_key` 和 `_last_value` 在类的外部是看不到的,从逻辑上说,修改它们的值,外部是无有感知的,因此也就不会破坏逻辑上的 const.
为了解决这一矛盾,我们用 mutable 来修饰 `_last_key` 和 `_last_value`,以便在 lookup 函数中更新缓存的键值.

