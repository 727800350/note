ref:

- [C语言中的static 详细分析](http://blog.csdn.net/keyeagle/article/details/6708077/)
- [static在C和C++中的用法和区别](http://blog.csdn.net/skyereeee/article/details/8000512)

c语言代码是以文件为单位来组织的,在一个源程序的所有源文件中,一个外部变量(注意不是局部变量)或者函数只能在一个源程序中定义一次,如果有重复定义的话编译器就会报错.
伴随着不同源文件变量和函数之间的相互引用以及相互独立的关系,产生了extern和static关键字.

一个进程在内存中的布局
```
----------
栈区
----------
堆栈增长区
----------
堆区
----------
其他段
----------
.bbs 段
----------
.data 段
----------
.text 段
----------
```
其中

- .text段保存进程所执行的程序二进制文件,
- .data段保存进程所有的已初始化的全局变量
- .bss段保存进程未初始化的全局变量(其他段中还有很多乱七八糟的段,暂且不表).

在进程的整个生命周期中,.data段和.bss段内的数据时跟整个进程同生共死的,也就是在进程结束之后这些数据才会寿终就寝.

### static全局变量
当一个进程的全局变量被声明为static之后,就是静态全局变量.
静态全局变量和其他的全局变量的存储地点并没有区别,都是在.data段(已初始化)或者.bss段(未初始化)内,但是它只在定义它的源文件内有效,其他源文件无法访问它.

### static局部变量
普通的局部变量在栈空间上分配,这个局部变量所在的函数被多次调用时,每次调用这个局部变量在栈上的位置都不一定相同.
局部变量也可以在堆上动态分配,但是记得使用完这个堆空间后要释放之.

static局部变量中文名叫静态局部变量.它与普通的局部变量比起来有如下几个区别:

1. 位置:静态局部变量被编译器放在全局存储区.data(注意:不在.bss段内,原因见3)),所以它虽然是局部的,但是在程序的整个生命周期中存在.
2. 访问权限:静态局部变量只能被其作用域内的变量或函数访问.也就是说虽然它会在程序的整个生命周期中存在,由于它是static的,它不能被其他的函数和源文件访问.
3. 值:静态局部变量如果没有被用户初始化,则会被编译器自动赋值为0,以后每次调用静态局部变量的时候都用上次调用后的值.
	这个比较好理解,每次函数调用静态局部变量的时候都修改它然后离开,下次读的时候从全局存储区读出的静态局部变量就是上次修改后的值.

需要注意的是由于static局部变量的这种特性,使得含静态局部变量的函数变得不可重入,即每次调用可能会产生不同的结果.这在多线程编程时可能会成为一种隐患.需要多加注意.

### static函数
相信大家还记得C++面向对象编程中的private函数,私有函数只有该类的成员变量或成员函数可以访问.
在C语言中,也有"private函数",它就是接下来要说的static函数,完成面向对象编程中private函数的功能.

当你的程序中有很多个源文件的时候,你肯定会让某个源文件只提供一些外界需要的接口,
其他的函数可能是为了实现这些接口而编写,这些其他的函数你可能并不希望被外界(非本源文件)所看到,这时候就可以用static修饰这些"其他的函数".

所以static函数的作用域是本源文件,把它想象为面向对象中的private函数就可以了.

### 静态数据成员／成员函数(C++特有)
C++ 重用了这个关键字,并赋予它与前面不同的第三种含义:表示属于一个类而不是属于此类的任何特定对象的变量和函数. 这是与普通成员函数的最大区别, 也是其应用所在.  
比如在对某一个类的对象进行计数时, 计数生成多少个类的实例, 就可以用到静态数据成员.  
在这里面, static既不是限定作用域的, 也不是扩展生存期的作用, 而是指示变量/函数在此类中的唯一性. 这也是"属于一个类而不是属于此类的任何特定对象的变量和函数"的含义. 
因为它是对整个类来说是唯一的,因此不可能属于某一个实例对象的.  
(针对静态数据成员而言, 成员函数不管是否是static, 在内存中只有一个副本, 普通成员函数调用时, 需要传入this指针, static成员函数调用时, 没有this指针)

