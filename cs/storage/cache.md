[阿里一面:关于【缓存穿透,缓存击穿,缓存雪崩,热点数据失效】问题的解决方案](https://juejin.cn/post/6844903807797690376)

# 缓存穿透
正常情况下,我们去查询数据都是存在.
那么请求去查询一条压根儿数据库中根本就不存在的数据,也就是缓存和数据库都查询不到这条数据,但是请求每次都会打到数据库上面去.
这种查询不存在数据的现象我们称为缓存穿透.

试想一下,如果有黑客会对你的系统进行攻击,拿一个不存在的id 去查询数据,会产生大量的请求到数据库去查询.可能会导致你的数据库
由于压力过大而宕掉.

如何解决

**缓存空值**

之所以会发生穿透,就是因为缓存中没有存储这些空数据的key.从而导致每次查询都到数据库去了.
那么我们就可以为这些key对应的值设置为null 丢到缓存里面去.后面再出现查询这个key 的请求的时候,直接返回null .
这样,就不用在到数据库中去走一圈了,但是别忘了设置过期时间.

**BloomFilter**

BloomFilter 类似于一个hbase set 用来判断某个元素(key)是否存在于某个集合中.
这种方式在大数据场景应用比较多,比如 Hbase 中使用它去判断数据是否在磁盘上.还有在爬虫场景判断url 是否已经被爬取过.
这种方案可以加在第一种方案中,在缓存之前在加一层BloomFilter, 在查询的时候先去BloomFilter 去查询key 是否存在,如果不存在就
直接返回, 存在再走查缓存 -> 查DB.

针对于一些恶意攻击,攻击带过来的大量key 是不存在的,那么我们采用第一种方案就会缓存大量不存在key的数据.
此时我们采用第一种方案就不合适了,我们完全可以先对使用第二种方案进行过滤掉这些key.
针对这种key异常多,请求重复率比较低的数据,我们就没有必要进行缓存,使用第二种方案直接过滤掉.
而对于空数据的key有限的,重复率比较高的,我们则可以采用第一种方式进行缓存.

# 缓存击穿
缓存击穿是我们可能遇到的第二个使用缓存方案可能遇到的问题.
在平常高并发的系统中,大量的请求同时查询一个 key 时,此时这个key正好失效了,就会导致大量的请求都打到数据库上面去.这种现象我
们称为缓存击穿.

如何解决

上面的现象是多个线程同时去查询数据库的这条数据,那么我们可以在第一个查询数据的请求上使用一个互斥锁来锁住它.
其他的线程走到这一步拿不到锁就等着,等第一个线程查询到了数据,然后做缓存.后面的线程进来发现已经有缓存了,就直接走缓存.

# 缓存雪崩
缓存雪崩的情况是说,当某一时刻发生大规模的缓存失效的情况,比如你的缓存服务宕机了,会有大量的请求进来直接打到DB上面.结果就是
DB 撑不住,挂掉.

使用集群缓存,保证缓存服务的高可用,
这种方案就是在发生雪崩前对缓存集群实现高可用,如果是使用Redis,可以使用 主从+哨兵, Redis Cluster 来避免Redis 全盘崩溃的情况.

还可以使用两级缓存, local cache + redis cache

