[LSM,B 树,B+树,B\*对比](https://www.jianshu.com/p/3fb899684392)

目前常见的主要的三种存储引擎是:哈希,B+树,LSM树:

- 哈希存储引擎:是哈希表的持久化实现,支持增,删,改以及随机读取操作,但不支持顺序扫描,对应的存储系统为key-value存储系统.对于key-value的插入以及查询,哈希表的复杂度都是O(1),明显比树的操作O(n)快,如果不需要有序的遍历数据,哈希表性能最好.
- B+树存储引擎是B+树的持久化实现,不仅支持单条记录的增,删,读,改操作,还支持顺序扫描(B+树的叶子节点之间的指针),对应的存储系统就是关系数据库(Mysql等).
- LSM树(Log-Structured Merge Tree)存储引擎和B+树存储引擎一样,同样支持增,删,读,改,顺序扫描操作.而且通过批量存储技术规避磁盘随机写入问题.当然凡事有利有弊,LSM树和B+树相比,LSM树牺牲了部分读性能,用来大幅提高写性能.

上面三种引擎中,LSM树存储引擎的代表数据库就是HBase.

LSM树核心思想的核心就是放弃部分读能力,换取写入的最大化能力.
LSM Tree, 这个概念就是结构化合并树的意思,它的核心思路其实非常简单,就是假定内存足够大,因此不需要每次有数据更新就必须将数据写入到磁盘中,而可以先将最新的数据驻留在内存中,
等到积累到足够多之后,再使用归并排序的方式将内存内的数据合并追加到磁盘队尾(因为所有待排序的树都是有序的,可以通过合并排序的方式快速合并到一起).

日志结构的合并树(LSM-tree)是一种基于硬盘的数据结构,与B+tree相比,能显著地减少硬盘磁盘臂的开销,并能在较长的时间提供对文件的高速插入(删除).
然而LSM-tree在某些情况下,特别是在查询需要快速响应时性能不佳.通常LSM-tree适用于索引插入比检索更频繁的应用系统.

LSM树和B+树的差异主要在于读性能和写性能进行权衡.在牺牲的同时寻找其余补救方案:

LSM具有批量特性,存储延迟.当写读比例很大的时候(写比读多),LSM树相比于B树有更好的性能.因为随着insert操作,为了维护B+树结构,节点分裂.读磁盘的随机读写概率会变大,性能会逐渐减弱.

B树的写入过程:对B树的写入过程是一次原位写入的过程,主要分为两个部分,首先是查找到对应的块的位置,然后将新数据写入到刚才查找到的数据块中,然后再查找到块所对应的磁盘物理位置,将数据写入去.
当然,在内存比较充足的时候,因为B树的一部分可以被缓存在内存中,所以查找块的过程有一定概率可以在内存内完成,不过为了表述清晰,我们就假定内存很小,只够存一个B树块大小的数据吧.
可以看到,在上面的模式中,需要两次随机寻道(一次查找,一次原位写),才能够完成一次数据的写入,代价还是很高的.

LSM优化方式:

- Bloom filter: 就是个带随机概率的bitmap,可以快速的告诉你,某一个小的有序结构里有没有指定的那个数据的.于是就可以不用二分查找,而只需简单的计算几次就能知道数据是否在某个小集合里啦.效率得到了提升,但付出的是空间代价.
- compact:小树合并为大树:因为小树性能有问题,所以要有个进程不断地将小树合并到大树上,这样大部分的老数据查询也可以直接使用log2N的方式找到,不需要再进行`(N/m)*log2n`的查询了
